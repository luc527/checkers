[1mdiff --git a/build_interface_test.txt b/build_interface_test.txt[m
[1mindex 4d16aef..e02ece7 100644[m
[1m--- a/build_interface_test.txt[m
[1m+++ b/build_interface_test.txt[m
[36m@@ -1 +1 @@[m
[31m-gcc -o intest interface.c util.c checkers.h -lncurses[m
[32m+[m[32mgcc -o intest interface.c util.c language.c checkers.h -lncurses[m
[1mdiff --git a/checkers.h b/checkers.h[m
[1mindex d75d41d..36d389d 100644[m
[1m--- a/checkers.h[m
[1m+++ b/checkers.h[m
[36m@@ -18,13 +18,17 @@[m [mtypedef enum {[m
     TIE_MSG,[m
     CURRENT_PLAYER,[m
     WHITE_PLAYER,[m
[31m-    BLACK_PLAYER[m
[32m+[m[32m    BLACK_PLAYER,[m
[32m+[m	[32mMUST_SELECT_MOVEMENT,[m
[32m+[m	[32mALREADY_SELECTED_MOVEMENT,[m
[32m+[m	[32mINVALID_MSG_OR_LANG_CODE[m
 } Message;[m
[31m-#define NMESSAGES 11[m
[32m+[m[32m#define NMESSAGES 14[m
[32m+[m[32m#define MSGLEN 200[m
 [m
 void init_messages_array(void);[m
 [m
[31m-void printmsg(Message, Language);[m
[32m+[m[32mchar *getmsg(Message, Language);[m
 // }}}[m
 [m
 // Simple typedefs {{{[m
[1mdiff --git a/interface.c b/interface.c[m
[1mindex 0495ab6..0830efd 100644[m
[1m--- a/interface.c[m
[1m+++ b/interface.c[m
[36m@@ -1,6 +1,7 @@[m
 #include <ncurses.h>[m
 #include "checkers.h"[m
 [m
[32m+[m
 /* The board space is where the player will move their cursor[m
  * and choose what movement he is going to perform -- what[m
  * piece they're gonna move (the source) and where they're moving it[m
[36m@@ -57,7 +58,7 @@[m [mvoid bspace_init()[m
 {[m
 	// For now it'll occupy the whole screen[m
 	// Change when actually adding other things to the interface[m
[31m-	bspace.win = newwin(0, 0, 0, 0);[m
[32m+[m	[32mbspace.win = newwin(LINES/2, COLS/2, 0, 0);[m
 	bspace_reset();[m
 }[m
 [m
[36m@@ -188,26 +189,54 @@[m [mvoid bspace_select_dest()[m
 	}[m
 }[m
 [m
[31m-/* bspace_cancel_movement() is called to cancel the player's current movement.[m
[31m- * Calling it will enable the player to choose a different movement.[m
[32m+[m[32m/* bspace_undo_movement() is called to undo the player's last marked position.[m
[32m+[m[32m * If he has selected source and destination, calling it once will[m
[32m+[m[32m * just un-select the destination, and calling it once more will[m
[32m+[m[32m * un-select the source.[m
  */[m
[31m-void bspace_cancel_movement()[m
[32m+[m[32mvoid bspace_undo_movement()[m
 {[m
[31m-	bspace.chose_src = false;[m
[31m-	bspace.chose_dest = false;[m
[32m+[m	[32mif (bspace.chose_dest) bspace.chose_dest = false;[m
[32m+[m	[32melse bspace.chose_src = false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m// ------------------------------[m
[32m+[m
[32m+[m[32m// TODO change to extern when integrating with checkers.c[m
[32m+[m[32mLanguage language = EN;[m
[32m+[m
[32m+[m[32mWINDOW *msgwin;[m
[32m+[m
[32m+[m[32mvoid msgwin_init()[m
[32m+[m[32m{[m
[32m+[m	[32mmsgwin = newwin(LINES/2, COLS/2, LINES/2+1, 0);[m
 }[m
 [m
[32m+[m[32mvoid msgwin_print(char *msg)[m
[32m+[m[32m{[m
[32m+[m	[32mwclear(msgwin);[m
[32m+[m	[32mwmove(msgwin, 0, 0);[m
[32m+[m	[32mwaddstr(msgwin, msg);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m// ------------------------------[m
[32m+[m
[32m+[m
 void init_interface()[m
 {[m
 	initscr();[m
 	cbreak();[m
 	noecho();[m
 	curs_set(0);[m
[32m+[m	[32mmsgwin_init();[m
 	bspace_init();[m
 }[m
 [m
 void close_interface()[m
 {[m
[32m+[m	[32mdelwin(msgwin);[m
 	delwin(bspace.win);[m
 	endwin();[m
 }[m
[36m@@ -221,6 +250,7 @@[m [mvoid refresh_interface()[m
 	bspace_show();[m
 	refresh();[m
 	wrefresh(bspace.win);[m
[32m+[m	[32mwrefresh(msgwin);[m
 }[m
 [m
 [m
[36m@@ -241,25 +271,24 @@[m [mvoid get_movement_interactively(Position *src, Position *dest)[m
 		chtype ch = wgetch(bspace.win);[m
 		int yoffset = 0, xoffset = 0;[m
 		switch (ch) {[m
[32m+[m
[32m+[m			[32m// FIXME msgwin_print is working, but not with getmsg[m
[32m+[m
 		case 10:  // Enter[m
 			if (bspace.chose_src && bspace.chose_dest)[m
 				goto done;  // 'break' wouldn't break the loop, but the switch case[m
[31m-			// TODO else: print that the player has to perform a movement[m
[31m-			break;[m
[32m+[m			[32melse[m
[32m+[m				[32mmsgwin_print(getmsg(MUST_SELECT_MOVEMENT, language));[m
 		case 'u':[m
[31m-			bspace_cancel_movement();[m
[31m-			// TODO make undo just cancel the last action:[m
[31m-			// if player has chosen source and destination,[m
[31m-			// pressing u once just undoes the destination,[m
[31m-			// and pressing it once more undoes the whole movement[m
[32m+[m			[32mbspace_undo_movement();[m
 			break;[m
 		case 'm':[m
 			if (!bspace.chose_src)[m
 				bspace_select_src();[m
 			else if (!bspace.chose_dest)[m
 				bspace_select_dest();[m
[31m-			// TODO else: status message with error (you must cancel the[m
[31m-			// movement or press ENTER at this point)[m
[32m+[m			[32melse[m
[32m+[m				[32mmsgwin_print(getmsg(ALREADY_SELECTED_MOVEMENT, language));[m
 			break;[m
 		case 'w': yoffset =  1; break;[m
 		case 's': yoffset = -1; break;[m
[1mdiff --git a/language.c b/language.c[m
[1mindex 859a33d..6851c93 100644[m
[1m--- a/language.c[m
[1m+++ b/language.c[m
[36m@@ -1,36 +1,46 @@[m
 #include <stdio.h>[m
 #include "checkers.h"[m
 [m
[31m-char *messages[NLANGS][NMESSAGES];[m
[32m+[m[32mchar *msgs[NLANGS][NMESSAGES];[m
 [m
 static void init_pt()[m
 {[m
[31m-    messages[PT][SOURCE_PROMPT] = "> Origem: ";[m
[31m-    messages[PT][DESTINATION_PROMPT] = "> Destino: ";[m
[31m-    messages[PT][NOT_AN_OPTION] = "Essa nao e uma opÃ§Ã£o. Tente novamente.\n";[m
[31m-    messages[PT][MUST_CAPTURE_WITH] = "Voce deve capturar com uma das seguintes pecas: ";[m
[31m-    messages[PT][MUST_PERFORM_SEQUENTIAL_CAPTURE] = "Voce deve realizar uma captura sequencial a partir de ";[m
[31m-    messages[PT][WHITE_WINS_MSG] = "Branco vence!\n";[m
[31m-    messages[PT][BLACK_WINS_MSG] = "Preto vence!\n";[m
[31m-    messages[PT][TIE_MSG] = "Empate.\n";[m
[31m-    messages[PT][CURRENT_PLAYER] = "Jogador atual: ";[m
[31m-    messages[PT][WHITE_PLAYER] = "branco (o@)\n";[m
[31m-    messages[PT][BLACK_PLAYER] = "preto (*X)\n";[m
[32m+[m[32m    msgs[PT][SOURCE_PROMPT] = "> Origem: ";[m
[32m+[m[32m    msgs[PT][DESTINATION_PROMPT] = "> Destino: ";[m
[32m+[m[32m    msgs[PT][NOT_AN_OPTION] = "Essa nao e uma opÃ§Ã£o. Tente novamente.\n";[m
[32m+[m[32m    msgs[PT][MUST_CAPTURE_WITH] = "Voce deve capturar com uma das seguintes pecas: ";[m
[32m+[m[32m    msgs[PT][MUST_PERFORM_SEQUENTIAL_CAPTURE] = "Voce deve realizar uma captura sequencial a partir de ";[m
[32m+[m[32m    msgs[PT][WHITE_WINS_MSG] = "Branco vence!\n";[m
[32m+[m[32m    msgs[PT][BLACK_WINS_MSG] = "Preto vence!\n";[m
[32m+[m[32m    msgs[PT][TIE_MSG] = "Empate.\n";[m
[32m+[m[32m    msgs[PT][CURRENT_PLAYER] = "Jogador atual: ";[m
[32m+[m[32m    msgs[PT][WHITE_PLAYER] = "branco (o@)\n";[m
[32m+[m[32m    msgs[PT][BLACK_PLAYER] = "preto (*X)\n";[m
[32m+[m	[32mmsgs[PT][MUST_SELECT_MOVEMENT] = "Voce deve selecionar um movimento.";[m
[32m+[m	[32mmsgs[PT][ALREADY_SELECTED_MOVEMENT] = "Voce ja selecionou um movimento."[m
[32m+[m[32m                                          " Cancele ou confirme-o.";[m
[32m+[m	[32mmsgs[PT][INVALID_MSG_OR_LANG_CODE] = "ERRO: Tentativa de imprimir mensagem invalida"[m
[32m+[m	[32m                                     " e/ou mensagem num idioma invalido.";[m
 }[m
 [m
 static void init_en()[m
 {[m
[31m-    messages[EN][SOURCE_PROMPT] = "> Source: ";[m
[31m-    messages[EN][DESTINATION_PROMPT] = "> Destination: ";[m
[31m-    messages[EN][NOT_AN_OPTION] = "That is not an option. Try again.\n";[m
[31m-    messages[EN][MUST_CAPTURE_WITH] = "You must capture with one of the following: ";[m
[31m-    messages[EN][MUST_PERFORM_SEQUENTIAL_CAPTURE] = "You must perform a sequential capture from: ";[m
[31m-    messages[EN][WHITE_WINS_MSG] = "White wins!\n";[m
[31m-    messages[EN][BLACK_WINS_MSG] = "Black wins!\n";[m
[31m-    messages[EN][TIE_MSG] = "It's a tie.\n";[m
[31m-    messages[EN][CURRENT_PLAYER] = "Current player: ";[m
[31m-    messages[EN][WHITE_PLAYER] = "white (o@)\n";[m
[31m-    messages[EN][BLACK_PLAYER] = "black (*X)\n";[m
[32m+[m[32m    msgs[EN][SOURCE_PROMPT] = "> Source: ";[m
[32m+[m[32m    msgs[EN][DESTINATION_PROMPT] = "> Destination: ";[m
[32m+[m[32m    msgs[EN][NOT_AN_OPTION] = "That is not an option. Try again.\n";[m
[32m+[m[32m    msgs[EN][MUST_CAPTURE_WITH] = "You must capture with one of the following: ";[m
[32m+[m[32m    msgs[EN][MUST_PERFORM_SEQUENTIAL_CAPTURE] = "You must perform a sequential capture from: ";[m
[32m+[m[32m    msgs[EN][WHITE_WINS_MSG] = "White wins!\n";[m
[32m+[m[32m    msgs[EN][BLACK_WINS_MSG] = "Black wins!\n";[m
[32m+[m[32m    msgs[EN][TIE_MSG] = "It's a tie.\n";[m
[32m+[m[32m    msgs[EN][CURRENT_PLAYER] = "Current player: ";[m
[32m+[m[32m    msgs[EN][WHITE_PLAYER] = "white (o@)\n";[m
[32m+[m[32m    msgs[EN][BLACK_PLAYER] = "black (*X)\n";[m
[32m+[m	[32mmsgs[EN][MUST_SELECT_MOVEMENT] = "You must select a movement.";[m
[32m+[m	[32mmsgs[EN][ALREADY_SELECTED_MOVEMENT] = "You already selected a movement."[m
[32m+[m	[32m                                      " Either undo or confirm it.";[m
[32m+[m	[32mmsgs[EN][INVALID_MSG_OR_LANG_CODE] = "ERROR: Attempted to print invalid message"[m
[32m+[m	[32m                                     " and/or message in invalid language.";[m
 }[m
 [m
 void init_messages_array()[m
[36m@@ -40,13 +50,10 @@[m [mvoid init_messages_array()[m
 }[m
 [m
 [m
[31m-void printmsg(Message msg, Language lang)[m
[32m+[m[32mchar *getmsg(Message msg, Language lang)[m
 {[m
[31m-    if (msg >= 0 && msg < NMESSAGES && lang >= 0 && lang < NLANGS) {[m
[31m-        printf("%s", messages[lang][msg]);[m
[31m-    } else {[m
[31m-        printf("Attempted to print invalid message (%d) and/or message in invalid language (%d).\n",[m
[31m-                msg, lang);[m
[31m-    }[m
[32m+[m	[32mif (msg < 0 || msg >= NMESSAGES || lang < 0 || lang >= NLANGS)[m
[32m+[m		[32mmsg = INVALID_MSG_OR_LANG_CODE;[m
[32m+[m	[32mreturn msgs[lang][msg];[m
 }[m
 [m
